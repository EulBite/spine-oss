{
  "_comment": "Deterministic test vectors for Spine SDK cross-language compatibility",
  "_version": "1.0.0",
  "_generated": "2026-01-24",
  "_provenance": "All hash digests generated by Python reference implementation (spine_client.crypto)",
  "format_version": 1,
  "hash_algorithm": "blake3",
  "hash_lengths": {
    "hash_hex_chars": 64,
    "sig_hex_chars": 128
  },

  "canonical_json": {
    "_description": "RFC 8785-like canonical JSON + Unicode NFC normalization (keys and string values)",
    "_key_ordering": "Sort keys after NFC normalization, by Unicode codepoint order (lexicographic on UTF-8 bytes)",
    "cases": [
      {
        "name": "key_ordering",
        "input": {"z": 1, "a": 2, "m": 3},
        "expected_utf8": "{\"a\":2,\"m\":3,\"z\":1}"
      },
      {
        "name": "no_whitespace",
        "input": {"key": "value", "nested": {"inner": 123}},
        "expected_utf8": "{\"key\":\"value\",\"nested\":{\"inner\":123}}"
      },
      {
        "name": "unicode_nfc_cafe_composed",
        "input": {"name": "caf√©"},
        "_note": "√© as single codepoint U+00E9",
        "expected_utf8": "{\"name\":\"caf√©\"}"
      },
      {
        "name": "unicode_nfc_cafe_decomposed",
        "input": {"name": "cafe\u0301"},
        "_note": "e + combining acute U+0065 U+0301 - must normalize to same as composed",
        "expected_utf8": "{\"name\":\"caf√©\"}"
      },
      {
        "name": "unicode_nfc_key_normalization",
        "input": {"cafe\u0301": "value"},
        "_note": "key normalization - decomposed key must normalize",
        "expected_utf8": "{\"caf√©\":\"value\"}"
      },
      {
        "name": "unicode_nfc_collision_warning",
        "_note": "IMPORTANT: If two keys normalize to same string after NFC, behavior is undefined (implementation-dependent). Implementations SHOULD reject or warn. This case documents that NFD and NFC forms of same key produce identical output.",
        "input_nfc": {"caf√©": 1},
        "input_nfd": {"cafe\u0301": 2},
        "both_normalize_to": "{\"caf√©\":...}",
        "_test_type": "documentation_only"
      },
      {
        "name": "unicode_emoji",
        "input": {"emoji": "üëãüåç"},
        "expected_utf8": "{\"emoji\":\"üëãüåç\"}"
      },
      {
        "name": "unicode_cjk",
        "input": {"text": "Êó•Êú¨Ë™û‰∏≠ÊñáÌïúÍµ≠Ïñ¥"},
        "expected_utf8": "{\"text\":\"Êó•Êú¨Ë™û‰∏≠ÊñáÌïúÍµ≠Ïñ¥\"}"
      },
      {
        "name": "unicode_rtl",
        "input": {"arabic": "ŸÖÿ±ÿ≠ÿ®ÿß", "hebrew": "◊©◊ú◊ï◊ù"},
        "expected_utf8": "{\"arabic\":\"ŸÖÿ±ÿ≠ÿ®ÿß\",\"hebrew\":\"◊©◊ú◊ï◊ù\"}"
      },
      {
        "name": "special_chars_quotes",
        "input": {"msg": "He said \"hello\""},
        "expected_utf8": "{\"msg\":\"He said \\\"hello\\\"\"}"
      },
      {
        "name": "special_chars_backslash",
        "input": {"path": "c:\\users\\test"},
        "expected_utf8": "{\"path\":\"c:\\\\users\\\\test\"}"
      },
      {
        "name": "special_chars_newline",
        "input": {"text": "line1\nline2"},
        "expected_utf8": "{\"text\":\"line1\\nline2\"}"
      },
      {
        "name": "empty_object",
        "input": {},
        "expected_utf8": "{}"
      },
      {
        "name": "empty_array",
        "input": [],
        "expected_utf8": "[]"
      },
      {
        "name": "nested_deep",
        "input": {"a": {"b": {"c": {"d": 1}}}},
        "expected_utf8": "{\"a\":{\"b\":{\"c\":{\"d\":1}}}}"
      },
      {
        "name": "array_with_objects",
        "input": [{"b": 2}, {"a": 1}],
        "_note": "array order preserved, but object keys sorted",
        "expected_utf8": "[{\"b\":2},{\"a\":1}]"
      },
      {
        "name": "numeric_types",
        "input": {"int": 42, "neg": -17, "zero": 0},
        "expected_utf8": "{\"int\":42,\"neg\":-17,\"zero\":0}"
      },
      {
        "name": "boolean_null",
        "input": {"t": true, "f": false, "n": null},
        "expected_utf8": "{\"f\":false,\"n\":null,\"t\":true}"
      }
    ]
  },

  "hash_payload": {
    "_description": "Tests for BLAKE3 payload hashing",
    "_note": "Hash is computed over canonical_json(payload)",
    "cases": [
      {
        "name": "simple_event",
        "payload": {"event": "test"},
        "expected_canonical": "{\"event\":\"test\"}",
        "expected_hash_blake3": "ba0ec9bd9cf1b301fae5608349497d6ac27dd1ea071ed9469b8894ba58f385b8"
      },
      {
        "name": "empty_payload",
        "payload": {},
        "expected_canonical": "{}",
        "expected_hash_blake3": "6e46dd10defc9b56c29a6ec56b508c21f54c08192194e4df25bf36f0c9c3c279"
      },
      {
        "name": "unicode_payload",
        "payload": {"user": "caf√©", "city": "Êù±‰∫¨"},
        "expected_canonical": "{\"city\":\"Êù±‰∫¨\",\"user\":\"caf√©\"}",
        "expected_hash_blake3": "dcb71029975d874f9197eedb1a838f3086a40237ef6d07b865f7bbdf22cd5897"
      },
      {
        "name": "login_event",
        "payload": {
          "event_type": "user.login",
          "user_id": "alice",
          "ip_address": "192.168.1.1",
          "success": true
        },
        "expected_canonical": "{\"event_type\":\"user.login\",\"ip_address\":\"192.168.1.1\",\"success\":true,\"user_id\":\"alice\"}",
        "expected_hash_blake3": "ff4ae8aaf47e8bea7408a02304573acf9dcd21d103a8126b355430ba38d7156d"
      }
    ]
  },

  "entry_hash": {
    "_description": "Tests for entry hash computation (chain linking)",
    "_format": "BLAKE3(seq_le_u64 || ts_ns_le_i64 || prev_hash_utf8 || payload_hash_utf8)",
    "_format_note": "prev_hash and payload_hash are concatenated as lowercase hex strings (64 ASCII chars), NOT raw 32-byte hash values",
    "_payload_ref_note": "payload_hash values reference hash_payload test cases - test runner should validate consistency",
    "cases": [
      {
        "name": "genesis_entry",
        "_payload_ref": "hash_payload.simple_event",
        "seq": 1,
        "timestamp_ns": 1737720000000000000,
        "prev_hash": "0000000000000000000000000000000000000000000000000000000000000000",
        "payload_hash": "ba0ec9bd9cf1b301fae5608349497d6ac27dd1ea071ed9469b8894ba58f385b8",
        "expected_entry_hash": "77adfc6abdc08c5e9e8f1da10b12f96f11a2609659e8bc5ea9d3854dd99c05db"
      },
      {
        "name": "second_entry",
        "_payload_ref": "hash_payload.empty_payload",
        "seq": 2,
        "timestamp_ns": 1737720001000000000,
        "prev_hash": "77adfc6abdc08c5e9e8f1da10b12f96f11a2609659e8bc5ea9d3854dd99c05db",
        "payload_hash": "6e46dd10defc9b56c29a6ec56b508c21f54c08192194e4df25bf36f0c9c3c279",
        "expected_entry_hash": "5a9766d525452f87207c409393beeb39bfcd3ca40e1ad1c2a1abb1c2f08f9c32"
      }
    ]
  },

  "timestamp_conversion": {
    "_description": "Tests for ISO timestamp to nanoseconds conversion",
    "_implementation_note": "MUST use integer arithmetic; float-based conversions lose precision at nanosecond scale",
    "cases": [
      {
        "name": "unix_epoch",
        "iso": "1970-01-01T00:00:00+00:00",
        "expected_ns": 0
      },
      {
        "name": "with_microseconds",
        "iso": "2025-01-24T12:00:00.123456+00:00",
        "expected_ns": 1737720000123456000
      },
      {
        "name": "no_microseconds",
        "iso": "2025-01-24T12:00:00+00:00",
        "expected_ns": 1737720000000000000
      },
      {
        "name": "timezone_offset",
        "iso": "2025-01-24T13:00:00+01:00",
        "_note": "13:00 in +01:00 = 12:00 in UTC",
        "expected_ns": 1737720000000000000
      },
      {
        "name": "negative_timezone",
        "iso": "2025-01-24T07:00:00-05:00",
        "_note": "07:00 in -05:00 = 12:00 in UTC",
        "expected_ns": 1737720000000000000
      },
      {
        "name": "y2k38_boundary",
        "iso": "2038-01-19T03:14:07+00:00",
        "_note": "32-bit Unix timestamp overflow boundary",
        "expected_ns": 2147483647000000000
      },
      {
        "name": "far_future",
        "iso": "2100-12-31T23:59:59.999999+00:00",
        "_note": "Tests 64-bit timestamp handling",
        "expected_ns": 4133980799999999000
      }
    ]
  },

  "corrupted_wal": {
    "_description": "Test cases for corrupted/malformed WAL handling",
    "cases": [
      {
        "name": "truncated_json",
        "line": "{\"event\": \"incomplete",
        "should_skip": true,
        "_note": "Missing closing brace and quote"
      },
      {
        "name": "invalid_json",
        "line": "not json at all",
        "should_skip": true
      },
      {
        "name": "empty_line",
        "line": "",
        "should_skip": true
      },
      {
        "name": "whitespace_only",
        "line": "   \t  ",
        "should_skip": true
      },
      {
        "name": "valid_minimal",
        "line": "{\"event\": \"test\"}",
        "_note": "Valid minimal JSON - should parse",
        "should_parse": true
      },
      {
        "name": "missing_required_field",
        "line": "{\"event_id\": \"evt_123\", \"seq\": 1}",
        "_note": "Missing payload_hash, prev_hash, etc.",
        "should_reject_as_record": true
      }
    ]
  },

  "signature_verification": {
    "_description": "Ed25519 signature test vectors with known keys",
    "_note": "Using RFC 8032 test vector for reproducibility",
    "cases": [
      {
        "name": "rfc8032_test1",
        "_note": "RFC 8032 Section 7.1 Test 1",
        "private_key_hex": "9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60",
        "public_key_hex": "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a",
        "message_hex": "",
        "signature_hex": "e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b"
      },
      {
        "name": "rfc8032_test2",
        "_note": "RFC 8032 Section 7.1 Test 2",
        "private_key_hex": "4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb",
        "public_key_hex": "3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c",
        "message_hex": "72",
        "signature_hex": "92a009a9f0d4cab8720e820b5f642540a2b27b5416503f8fb3762223ebdb69da085ac1e43e15996e458f3613d0f11d8c387b2eaeb4302aeeb00d291612bb0c00"
      }
    ]
  },

  "error_cases": {
    "_description": "Expected error scenarios for verification (specification narrative, not deterministic test vectors)",
    "_test_type": "documentation_only",
    "cases": [
      {
        "name": "chain_break",
        "description": "Record with wrong prev_hash (chain integrity violation)",
        "scenario": "Second record has prev_hash that doesn't match first record's entry_hash",
        "expected_error_type": "chain_break",
        "expected_error_at_sequence": 2
      },
      {
        "name": "sequence_gap",
        "description": "Missing sequence number in chain",
        "scenario": "Records with seq 1 and seq 3, but no seq 2",
        "expected_error_type": "sequence_gap",
        "expected_error_details": "missing sequence 2 after 1"
      },
      {
        "name": "invalid_genesis",
        "description": "Genesis entry with non-zero prev_hash",
        "scenario": "First record (seq=1) has prev_hash that is not all zeros",
        "expected_error_type": "invalid_genesis",
        "expected_error_details": "genesis prev_hash must be 64 zeros"
      },
      {
        "name": "timestamp_regression",
        "description": "Timestamp going backwards in chain",
        "scenario": "Record N+1 has earlier timestamp than record N",
        "expected_error_type": "timestamp_regression"
      },
      {
        "name": "invalid_signature",
        "description": "Signature doesn't match entry_hash",
        "scenario": "sig_client field doesn't verify against computed entry_hash with public_key",
        "expected_error_type": "invalid_signature"
      },
      {
        "name": "hash_mismatch",
        "description": "Payload hash doesn't match actual payload",
        "scenario": "payload_hash field doesn't equal BLAKE3(canonical_json(payload))",
        "expected_error_type": "invalid_hash"
      }
    ]
  },

  "implementation_notes": {
    "endianness": "Spine uses little-endian for all binary integers (u64/i64) regardless of platform",
    "hash_encoding": "Hash strings are lowercase hex (64 chars = 256 bits)",
    "signature_encoding": "Ed25519 signatures are lowercase hex (128 chars = 64 bytes)",
    "timestamp_precision": "Nanoseconds since Unix epoch (i64)",
    "unicode": "All strings NFC-normalized before hashing",
    "json_numbers": "Only JSON-compliant numbers; NaN/Infinity not allowed. Floats are discouraged for cross-language determinism."
  }
}
